* STM32 Training
  
** install programs
   1. java
   2. stlink util
   3. cubemx
   4. truestudio
  
      
** dive into stm32l0
*** blink led
*** over view of debugger windows


** tips

*** stlink/v2
    1. page 12 chap 4.2 Connection with STM32
    2. page 13 Fig. 10 JTAG debugging flat ribbon layout
    3. page 14 chap 4.3 ST-LINK/V2 status LED

*** trueStudio
   
**** keyboard shortcut remap
     1. Window -> Preference -> General -> keys


**** keyboard shortcut
***** build/debug
     1. f11   - debug
     2. f8    - run
     3. C-b   - build current project(need to remap)
     4. C-f2  - terminate debug
	
***** editing
     1. C-S-f - format
     2. f3    - go to the definition
     3. Alt   - 'left arrow key' - back
     4. C-/   - comment the line
	
**** output generation
     1. right click on the project
     2. properties -> C/C++ Build -> setting -> tool setting -> MCU Post build outputs

	
** GPIO
   - 5 volt tolerant pins[file:./doc/stm32l052k6.pdf] table 16. pin descriptions
   - 2,7,8,9,12,13,14,15,18,19,20,21,22,23,24,25,26,27,28,29,30
*** OUTPUT

*** INPUT

*** External Interrupt(timer6 interrupt example)
    1. stm32l0xx_it.c(void EXTI0_1_IRQHandler(void))
    2. -> stm32l0xx_hal_gpio.c(void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin))
    3. -> stm32l0xx_hal_gpio.c(__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin))
    4. need to redefine the __weak function defined in stm32l0xx_hal_gpio.c in main.c
#+BEGIN_SRC C
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	//extern uint16_t dlyAmt;
if(GPIO_Pin == BTN_Pin){
	if(dlyAmt > 1000)
		dlyAmt = 0;
	else
		dlyAmt+= 100;
}
#+END_SRC

** Basic TIMER(timer6)
   - timers(TIM2,3,6 -> APB1, TIM21, 22 -> APB2) location(RM0376.pdf 62 page)
   - *Table 3. STM32L0x2 peripheral register boundary addresses*
*** Interrupt
    1 redefine HAL_TIM_PeriodElapsedCallback in main.c
    2 the prototype is defined in stm32l0xx_hal_tim.c as __weak 
    3. add *HAL_TIM_Base_Start_IT(&htim6)*; to main before while loop 
       
#+BEGIN_SRC C
//~~~~
void main(){

//~~~~
HAL_TIM_Base_Start_IT(&htim6);

//~~~~
while(1){

//~~~~

}
//~~~~
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM2) {
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */
  if(htim->Instance == TIM6)
  	 HAL_GPIO_TogglePin(GLED_GPIO_Port, GLED_Pin );
  /* USER CODE END Callback 1 */
}
#+END_SRC


** General Purpose TIMER(timer6)
*** pwm
    - CCR(Capture Compare REgister)

** ADC
   

#+BEGIN_SRC C
   
 while (1)
  {
	  //uint8_t pData[] = "Hello World\n\r";
	 // HAL_UART_Transmit(&huart1, pData, sizeof(pData), 0xffff);
		printf("Hello World: %d\t", dlyAmt);
		pAdc = 0;
		for (int i = 0; i < nSamples; i++) {
			HAL_ADC_Start(&hadc);
			HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
			pAdc += HAL_ADC_GetValue(&hadc);
		}
		//sprintf(msg, "ADC Value: %f\r\n", ((double)pAdc/8)*0.00081);
		//printf("ADC Value: %f\n\r", ((double)pAdc/8)*0.00081);
		printf("ADC Value: %d\n\r", pAdc/nSamples);
//	  HAL_GPIO_TogglePin(GLED_GPIO_Port, GLED_Pin );
	  HAL_Delay(dlyAmt);

  }

#+END_SRC
** Misc
   1. *TSC* -> touch sensor
