* STM32 Training
  
** Ordering Information
   - refer to 142 page of stm32l052k6.pdf
     
** Pin Descriptions
   - chap 4 of stm32l052k6.pdf
   
  
** FLASH Memory
   
*** Relation btn CPU frequency/Operation mode/NVM read time
   1. refer to page 72 of RM0376
      
*** Changing the CPU Frequency
   2.  refer to page 73 of RM0376
** STM32 Training Using CubeMX
  
*** install programs
    1. java
    2. stlink util
    3. cubemx
    4. truestudio
  
      
*** dive into stm32l0
**** blink led
**** over view of debugger windows


*** tips

**** stlink/v2
     1. page 12 chap 4.2 Connection with STM32
     2. page 13 Fig. 10 JTAG debugging flat ribbon layout
     3. page 14 chap 4.3 ST-LINK/V2 status LED

**** trueStudio
   
***** keyboard shortcut remap
      1. Window -> Preference -> General -> keys


***** keyboard shortcut
****** build/debug
      1. f11   - debug
      2. f8    - run
      3. f6    - step over
      4. f5    - step into
      5. C-b   - build current project(need to remap)
      6. C-f2  - terminate debug
	
****** editing
      1. C-S-f     - format
      2. f3        - go to the definition
      3. Alt       - 'left arrow key' - back
      4. C-/       - comment the line
      5. C-'Space' - auto complete
	
***** output generation
      1. right click on the project
      2. properties -> C/C++ Build -> setting -> tool setting -> MCU Post build outputs

	
*** GPIO
    - 5 volt tolerant pins[file:./doc/stm32l052k6.pdf] table 16. pin descriptions
    - 2,7,8,9,12,13,14,15,18,19,20,21,22,23,24,25,26,27,28,29,30
**** OUTPUT
     - refer to 'stm32l0xx_hal_gpio.c'
     #+BEGIN_SRC C
 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1 );
 HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1 );
 if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET){
 //...~~~
 }
    
     #+END_SRC

**** INPUT

**** External Interrupt(GPIO)
     1. stm32l0xx_it.c(void EXTI0_1_IRQHandler(void))
     2. -> stm32l0xx_hal_gpio.c(void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin))
     3. -> stm32l0xx_hal_gpio.c(__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin))
     4. need to redefine the __weak function defined in stm32l0xx_hal_gpio.c in main.c
 #+BEGIN_SRC C
 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
 {
	 //extern uint16_t dlyAmt;
 if(GPIO_Pin == BTN_Pin){
	 if(dlyAmt > 1000)
		 dlyAmt = 0;
	 else
		 dlyAmt+= 100;
 }
 #+END_SRC

*** Basic TIMER(timer6)
    - 'stm32l0xx_hal_tim.c'
    - timers(TIM2,3,6 -> APB1, TIM21, 22 -> APB2) location(RM0376.pdf 62 page)
    - *Table 3. STM32L0x2 peripheral register boundary addresses*
**** Interrupt
     1 redefine HAL_TIM_PeriodElapsedCallback in main.c
     2 the prototype is defined in stm32l0xx_hal_tim.c as __weak 
     3. add *HAL_TIM_Base_Start_IT(&htim6)*; to main before while loop 
       
 #+BEGIN_SRC C
 //~~~~
 void main(){

 //~~~~
 HAL_TIM_Base_Start_IT(&htim6);

 //~~~~
 while(1){

 //~~~~

 }
 //~~~~
 }

 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
 {
   /* USER CODE BEGIN Callback 0 */

   /* USER CODE END Callback 0 */
   if (htim->Instance == TIM2) {
     HAL_IncTick();
   }
   /* USER CODE BEGIN Callback 1 */
   if(htim->Instance == TIM6)
  	  HAL_GPIO_TogglePin(GLED_GPIO_Port, GLED_Pin );
   /* USER CODE END Callback 1 */
 }
 #+END_SRC


*** General Purpose TIMER(timer6)
**** pwm
     - CCR(Capture Compare Register)

*** ADC
   

 #+BEGIN_SRC C
   
  while (1)
   {
	   //uint8_t pData[] = "Hello World\n\r";
	  // HAL_UART_Transmit(&huart1, pData, sizeof(pData), 0xffff);
		 printf("Hello World: %d\t", dlyAmt);
		 pAdc = 0;
		 for (int i = 0; i < nSamples; i++) {
			 HAL_ADC_Start(&hadc);
			 HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
			 pAdc += HAL_ADC_GetValue(&hadc);
		 }
		 //sprintf(msg, "ADC Value: %f\r\n", ((double)pAdc/8)*0.00081);
		 //printf("ADC Value: %f\n\r", ((double)pAdc/8)*0.00081);
		 printf("ADC Value: %d\n\r", pAdc/nSamples);
 //	  HAL_GPIO_TogglePin(GLED_GPIO_Port, GLED_Pin );
	   HAL_Delay(dlyAmt);

   }

 #+END_SRC

*** Misc
    1. *TSC* -> touch sensor
      
*** RCC registers
**** RCC_CR
     1. refer RM0376 chap. 7.3 page 184

       
** treuStudio Project without cubeMX
   - [[https://youtu.be/iLGqiJFzNeo][Part1. Creattion of trueStudio Project without CubeMX]]
   - [[https://youtu.be/pxgRjPDgQuo][Part2. Debug and Run the project]]
     
     
*** GPIO Button & LED (input & output)
#+BEGIN_SRC C
//https://www.youtube.com/watch?v=zHHwbRdstoQ&list=PLRJhV4hUhIymmp5CCeIFPyxbknsdcXCc8&index=6
int main(void) {
	// 7.3.12 GPIO clock enable register(RCC_IOPENR)
	RCC->IOPENR |= RCC_IOPENR_GPIOAEN; // Enable GPIOA Clock.

	// 00: input, 01:general purpose output mode, 10:Alternate function mode, 11:Analog mode(reset state)
	// PA0 as output
	GPIOA->MODER &= ~(0x3 << 0);// Clear mode register for PA0
	GPIOA->MODER |=  (0x1 << 0); // set 0th bit

	/* PA15 as input pullup configuration for btn  */
// 0b00~~~~~~~ input mode
	GPIOA->MODER &= ~(0x3 << 30); // clear GPIOA->MODER[31:0]
// pullup, PUPDR 0b01~~~~~~~~~~~
	GPIOA->PUPDR &= ~(0x1 << 31); // clear 32nd bit
	GPIOA->PUPDR |= (0x1 << 30); // set 31st bit

	/* TODO - Add your application code here */
	while (1) {
		if (GPIOA->IDR & (0x1 << 15))
			GPIOA->ODR |= (0x1 << 0);
		else
			GPIOA->ODR &= ~(0x1 << 0);
	}

	return 0;
}
#+END_SRC

*** GPIO external interrupt
#+BEGIN_SRC C
//https://www.youtube.com/watch?v=wxgZ6kabX-k&list=PL6PplMTH29SHgRPDufZhfMRoFwRAIrzOp&index=53
#define Dly 100000
void WaitForAMoment(uint32_t Moment) {
	volatile uint32_t i, j;
	for (i = 0; i < Moment; i++) {
		j++;
	}
}

void EXTI4_15_IRQHandler() {
	static uint8_t flag = 0;

	if (EXTI->PR & EXTI_PR_PR15) {
		EXTI->PR |= EXTI_PR_PR15;

		if (flag) {
			flag = 0;
			GPIOA->BSRR = 1 << 1;
		} else {
			flag = 1;
			GPIOA->BRR = 1 << 1;
		}
	}
}

int main(void) {
	uint32_t ii = 0;

	/* TODO - Add your application code here */
	RCC->IOPENR |= RCC_IOPENR_GPIOAEN; // Enable GPIOA Clock.

	GPIOA->MODER &= ~(0x1 << 1); // PA0 as output
	GPIOA->MODER &= ~(0x1 << 3); // PA1 as output

	/* PA15 as input pullup configuration for btn  */
	// 0b00~~~~~~~ input mode
	GPIOA->MODER &= ~(0x3 << 30);
	// pullup, PUPDR 0b01~~~~~~~~~~~
	GPIOA->PUPDR &= ~(0x1 << 31); // clear 32nd bit
	GPIOA->PUPDR |=  (0x1 << 30); // set 31st bit

	// RM0376 cha 13
	EXTI->IMR  |= EXTI_IMR_IM15;  // interrupt mask
	EXTI->FTSR |= EXTI_FTSR_FT15; // falling edge detection

	// select PA15 among PB15, PC15,...refer RM0376 Ch 10 System configuration controller
	SYSCFG->EXTICR[3] |= ~(0xF << 12);

	// RM0376 cha 12
	NVIC_EnableIRQ(EXTI4_15_IRQn);
	NVIC_SetPriority(EXTI4_15_IRQn, 0);

	while (1) {

		GPIOA->BSRR = 1;

		WaitForAMoment(Dly);
		GPIOA->BRR = 1;

		WaitForAMoment(Dly);
		//RCC->AHBENR |= RCC_AHBENR_;

	}

	return 0;
}
#+END_SRC

*** Basic Timer(TIM6/7)
    - refer to page 559 of RM0376
*** SystciTimer
    - https://www.youtube.com/watch?v=aLCUDv_fgoU
     
 #+BEGIN_SRC C
 volatile int32_t TimeDelay;
 void SysTick_Handler() {
	 if (TimeDelay > 0)
		 TimeDelay--;
 }
 void Delay(uint32_t nTime) {
	 TimeDelay = nTime;
	 while (TimeDelay != 0)
		 ;
 }
 void Systic_Init(uint32_t ticks) {

	 //0xE000E010
	 SysTick->CTRL = 0; // disable Systic
	 SysTick->LOAD = ticks - 1; // Set reload register
	 //Set interrupt priority of SysTic to least urgency (i.e., largest priority value)
	 NVIC_SetPriority(SysTick_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
	 SysTick->VAL = 0;

	 // Select processor clock: 1=Processor clock, 0=external clock
	 //SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;

	 // Enables SysTick interrupt, 1=Enable, 0=Disable;
	 SysTick->CTRL |= 1 << 1;

	 // Enables SysTick
	 SysTick->CTRL |= 1;

 }
 int main(void) {
	 uint32_t ii = 0;
	 Systic_Init(100);
	 RCC->IOPENR |= RCC_IOPENR_GPIOAEN; // Enable GPIOA Clock.
	 GPIOA->MODER &= ~(0x1 << 1); // PA0 as output
	 /* TODO - Add your application code here */
	 while (1) {
		 ii++;
		 Delay(1000);
		 static uint8_t flag = 0;

		 if (flag) {
			 flag = 0;
			 GPIOA->BSRR = 1;
		 } else {
			 flag = 1;
			 GPIOA->BRR = 1;
		 }
	 }
	 return 0;
 }
 #+END_SRC
 
** util sources
 #+BEGIN_SRC C
 //https://www.youtube.com/watch?v=mlRM2UfrX4A
 #define numBtn 5
 char btnPressed[numBtn];
 int btnCounter[numBtn];
 char isBitCleared(char pinPort, char portBit)
 {
   return !((pinPort >> portBit) & 0x01);
 }
 char isBitSet(char pinPort, char portBit)
 {
   return ((pinPort >> portBit) & 0x01);
 }
 char isBtnPressed(int index,unsigned char pinPort,unsigned char Bitport,int numCount)
 {
   if (isBitcleared(pinPort,Bitport)){
     if (btnCounter[index]++ > numCount){
       if (!btnPressed[index]){
	 btnPressed[index]=1;
	 return 1;
       }
       btnCounter[index]=0;
     }
   } else{
     btnPressed[index]= 0;
     btnCounter[index]=0;
   }
   return 0;
 }


 #+END_SRC

** LCD schematic
[[[file:images/lcd.jpg]]]
